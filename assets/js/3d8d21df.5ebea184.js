"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[535],{5290:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return u},default:function(){return c}});var a=n(7462),i=n(3366),s=(n(7294),n(3905)),r=["components"],o={sidebar_position:1},l="About",p={unversionedId:"about",id:"about",isDocsHomePage:!1,title:"About",description:"This library provides basicfixedstring class template to enable fixed-size std::array semantic with standard-like string semantic.",source:"@site/docs/about.md",sourceDirName:".",slug:"/about",permalink:"/fixed_string/docs/about",editUrl:"https://github.com/unterumarmung/fixed_string/edit/add-documentation/documentation/docs/about.md",version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"basic_fixed_string",permalink:"/fixed_string/docs/api/basic_fixed_string"}},u=[{value:"Features",id:"features",children:[]},{value:"Possible usages",id:"possible-usages",children:[]},{value:"Examples",id:"examples",children:[]},{value:"Integration",id:"integration",children:[]},{value:"Compiler compatibility",id:"compiler-compatibility",children:[]}],d={toc:u};function c(e){var t=e.components,n=(0,i.Z)(e,r);return(0,s.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"about"},"About"),(0,s.kt)("p",null,"This library provides ",(0,s.kt)("inlineCode",{parentName:"p"},"basic_fixed_string")," class template to enable fixed-size ",(0,s.kt)("inlineCode",{parentName:"p"},"std::array")," semantic with standard-like string semantic."),(0,s.kt)("h2",{id:"features"},"Features"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"C++17 or higher"),(0,s.kt)("li",{parentName:"ul"},"Header-only"),(0,s.kt)("li",{parentName:"ul"},"Dependency-free")),(0,s.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"Warning")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Dependencies can be added later to enable lower C++ standards support."))),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"No dynamic allocations"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"constexpr")," as much as possible"),(0,s.kt)("li",{parentName:"ul"},"Can be used as class non-type template parameter ",(0,s.kt)("em",{parentName:"li"},"(since C++20)"))),(0,s.kt)("h2",{id:"possible-usages"},"Possible usages"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("h2",{parentName:"li",id:"make-your-own-edsl-with-c20s-class-non-type-template-parameter-feature"},"Make your own eDSL with C++20's class non-type template parameter feature"))),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/hanickadot/compile-time-regular-expressions"},"CTRE library")," uses similar class to make regular expressions in C++ more easy to use:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'std::optional<std::string_view> extract_number(std::string_view s) noexcept {\n    if (auto m = ctre::match<"[a-z]+([0-9]+)">(s)) {\n        return m.get<1>().to_view();\n    } else {\n        return std::nullopt;\n    }\n}\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("h2",{parentName:"li",id:"make-more-concise-apis"},"Make more concise APIs"))),(0,s.kt)("p",null,"For example, before ",(0,s.kt)("inlineCode",{parentName:"p"},"fixed_string")," if you needed to implement MD5 hash function, you'd write something like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"std::string hash_md5(std::string_view string);\n")),(0,s.kt)("p",null,"This solution has 2 downsides: "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"it can allocate"),(0,s.kt)("li",{parentName:"ul"},"it can return a string that is not 16 bytes")),(0,s.kt)("p",null,"With ",(0,s.kt)("inlineCode",{parentName:"p"},"fixed_string")," these 2 problems are solved:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"fixstr::fixed_string<16> hash_md5(std::string_view string);\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("h2",{parentName:"li",id:"use-in-a-free-standing-environment"},"Use in a free-standing environment"))),(0,s.kt)("p",null,"Returning to the example with the hash function: the implementation with ",(0,s.kt)("inlineCode",{parentName:"p"},"std::string")," as the return type has one more downside which is a consequence of possible allocations - it cannot be used in free-standing environments where is no dynamic memory."),(0,s.kt)("h2",{id:"examples"},"Examples"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Construction")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'constexpr fixstr::fixed_string foo = "foo";\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Concatenation")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'using namespace fixstr;\nconstexpr fixed_string first = "Hello, ";\nconstexpr fixed_string second = "World!";\nconstexpr auto result = first + second; // "Hello, World!"\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Comparison")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'using namespace fixstr;\nconstexpr fixed_string first = "Hello, ";\nconstexpr fixed_string second = "World!";\nstatic_assert(first == second); // false\nstatic_assert(first != second); // true\nstatic_assert(first < second);  // true\nstatic_assert(first <= second); // true\nstatic_assert(first > second);  // false \nstatic_assert(first >= second); // false\nstatic_assert(first <=> second != 0); // true\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Non-type template parameter")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'template <fixstr::fixed_string Foo>\nvoid bar()\n{\n    static_assert(Foo == "foo"sv);\n}\n\nvoid foo()\n{\n    bar<"foo">();\n}\n')),(0,s.kt)("h2",{id:"integration"},"Integration"),(0,s.kt)("p",null,"Since it's a header only library, you need just copy ",(0,s.kt)("inlineCode",{parentName:"p"},"fixed_string.hpp")," to your project."),(0,s.kt)("p",null,"If you are using ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/Microsoft/vcpkg/"},"vcpkg")," on your project for external dependencies, then you can use the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/microsoft/vcpkg/tree/master/ports/fixed-string"},(0,s.kt)("strong",{parentName:"a"},"fixed-string")," package"),"."),(0,s.kt)("p",null,"If you are using Conan on your project for external dependencies, then you can use the Conan recipe located in the root of the repository."),(0,s.kt)("h2",{id:"compiler-compatibility"},"Compiler compatibility"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"GCC >= 7.3"),(0,s.kt)("li",{parentName:"ul"},"Clang >= 5"),(0,s.kt)("li",{parentName:"ul"},"ICC >= 19.0.1"),(0,s.kt)("li",{parentName:"ul"},"MSVC >= 14.28 / Visual Studio 2019 (I don't have access to older VS versions right now, so it can work on older versions too)")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Using ",(0,s.kt)("inlineCode",{parentName:"strong"},"basic_fixed_string")," as class non-type template parameter full available in GCC >= 10 and VS 2019 16.9 or newer")))}c.isMDXComponent=!0}}]);